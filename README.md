1. Системы счисления
Описание программы
Программа преобразует десятичное число в систему счисления с произвольным основанием (от 2 до 36).

Ключевые функции
convertToBase(number, base, result) - преобразует число в заданную систему

isValidBase(base) - проверяет корректность основания

Алгоритм преобразования
Деление с остатком: число делится на основание новой системы

Сбор остатков: остатки от деления сохраняются (это цифры новой системы)

Обратный порядок: остатки читаются в обратном порядке (от последнего к первому)

Преобразование цифр: цифры 10-35 представляются буквами A-Z

Пример
text
Десятичное: 255
Основание: 16
Результат: FF
Специфические термины
Основание системы счисления - количество цифр, используемых в системе (например, 2 для двоичной, 10 для десятичной)

Остаток от деления - число, остающееся после целочисленного деления (например, 7 % 3 = 1)

2. Двоичное представление чисел
Описание программы
Программа показывает двоичное представление числа с учетом заданного количества байтов и формата (знаковый/беззнаковый).

Ключевые функции
checkNumberFits(number, bytes, isSigned) - проверяет, помещается ли число

printBinary(number, bytes, isSigned) - выводит двоичное представление

Форматы представления
Беззнаковый формат
Все биты используются для значения

Диапазон: от 0 до 2^(n)-1, где n - количество бит

Знаковый формат
Старший бит (самый левый) - знак (0 = "+", 1 = "-")

Остальные биты - значение

Используется дополнительный код для отрицательных чисел

Диапазон: от -2^(n-1) до 2^(n-1)-1

Специфические термины
Разрядная сетка - расположение битов в памяти компьютера

Дополнительный код - способ представления отрицательных чисел:

Инвертировать все биты числа (получить обратный код)

Прибавить 1 к результату

Старший бит - бит с наибольшим весом (самый левый)

Младший бит - бит с наименьшим весом (самый правый)

3. Алгоритм с добавлением бита
Описание программы
Программа реализует алгоритм обработки чисел: к двоичному коду добавляется бит в зависимости от четности суммы цифр исходного числа.

Алгоритм
Преобразовать число в двоичную систему

Вычислить сумму цифр десятичного числа

Если сумма четная → добавить '0' справа к двоичному коду

Если сумма нечетная → добавить '1' справа к двоичному коду

Преобразовать новое двоичное число обратно в десятичное

Повторить заданное количество раз

Ключевые функции
sumOfDigits(number) - вычисляет сумму цифр

decimalToBinary(number, binary) - преобразует в двоичную систему

binaryToDecimal(binary) - преобразует обратно в десятичную

Пример
text
Исходное число: 5 (сумма цифр: 5 - нечетная)
Двоичное: 101
Добавляем '1': 1011
Результат: 11
4. Код Хэмминга
Описание программы
Программа строит код Хэмминга - метод обнаружения и исправления одиночных ошибок в данных.

Что такое код Хэмминга?
Код Хэмминга добавляет контрольные биты к данным для обнаружения и исправления ошибок при передаче или хранении.

Алгоритм построения
Определение позиций: Контрольные биты размещаются на позициях, равных степеням двойки (1, 2, 4, 8...)

Размещение данных: Информационные биты занимают оставшиеся позиции

Вычисление контрольных битов: Каждый контрольный бит вычисляется как XOR определенных информационных битов

Контрольные биты
P1 контролирует биты: 1, 3, 5, 7, 9, 11...

P2 контролирует биты: 2, 3, 6, 7, 10, 11...

P4 контролирует биты: 4, 5, 6, 7, 12, 13, 14, 15...

P8 контролирует биты: 8, 9, 10, 11, 12, 13, 14, 15, 24-31...

Формула для количества контрольных битов
text
2^r ≥ m + r + 1
где: r - количество контрольных битов
      m - количество информационных битов
Пример для числа 11 (1011₂)
text
Информационные биты: 4
Контрольные биты: 3
Общая длина: 7 бит

Позиции: 1(P1) 2(P2) 3(D1) 4(P4) 5(D2) 6(D3) 7(D4)
Значения:   0     0     1     1     0     1     1
Код Хэмминга: 0011011
Специфические термины
Контрольный бит - дополнительный бит, используемый для проверки целостности данных

XOR (исключающее ИЛИ) - логическая операция:

0 XOR 0 = 0

0 XOR 1 = 1

1 XOR 0 = 1

1 XOR 1 = 0

Избыточность - добавление дополнительных битов для контроля ошибок

5. Стек на массиве
Описание программы
Реализация структуры данных "стек" (LIFO - Last In, First Out) на основе массива.

Основные операции
Инициализация - создание пустого стека

Push - добавление элемента на вершину

Pop - удаление элемента с вершины

Peek - просмотр вершины без удаления

isEmpty - проверка на пустоту

isFull - проверка на заполненность

Структура стека
c
typedef struct {
    int data[MAX_SIZE];  // массив для хранения элементов
    int top;             // индекс вершины стека (-1 если пуст)
} Stack;
Принцип работы
Добавление (Push): Увеличиваем top, записываем значение

Удаление (Pop): Возвращаем значение по индексу top, уменьшаем top

Вершина всегда на позиции data[top]

Пример
text
Push(10): top=0, data[0]=10
Push(20): top=1, data[1]=20
Pop(): возвращаем 20, top=0
Специфические термины
LIFO (Last In, First Out) - "последним пришел, первым ушел"

Вершина стека - позиция, куда добавляются и откуда удаляются элементы

Переполнение стека - попытка добавить элемент в полный стек

Опустошение стека - попытка удалить элемент из пустого стека

6. Очереди (линейная и кольцевая)
Описание программы
Реализация двух видов очередей: линейной (со сдвигом) и кольцевой.

Основные операции (для обоих типов)
Инициализация - создание пустой очереди

Enqueue - добавление элемента в конец

Dequeue - удаление элемента из начала

isEmpty - проверка на пустоту

isFull - проверка на заполненность

Линейная очередь со сдвигом
Структура
c
typedef struct {
    int data[MAX_SIZE];
    int front;  // индекс первого элемента (всегда 0)
    int rear;   // индекс последнего элемента
    int count;  // количество элементов
} LinearQueue;
Особенности
При удалении все элементы сдвигаются на одну позицию

Недостаток: операция Dequeue имеет сложность O(n)

front всегда равен 0

Кольцевая очередь
Структура
c
typedef struct {
    int data[MAX_SIZE];
    int front;  // индекс первого элемента
    int rear;   // индекс после последнего элемента
    int count;  // количество элементов
} CircularQueue;
Особенности
Использует кольцевую арифметику: index = (index + 1) % MAX_SIZE

Все операции имеют сложность O(1)

Полностью использует выделенную память

front и rear могут "заворачиваться" через границы массива

Ключевые отличия
Аспект	Линейная очередь	Кольцевая очередь
Сдвиг элементов	Да (при удалении)	Нет
Сложность Dequeue	O(n)	O(1)
Использование памяти	Может быть неэффективным	Полное
Логика	Простая	Сложнее (кольцевая арифметика)
Специфические термины
FIFO (First In, First Out) - "первым пришел, первым ушел"

Front (голова) - начало очереди (откуда удаляются элементы)

Rear (хвост) - конец очереди (куда добавляются элементы)

Кольцевая арифметика - использование операции modulo для "заворачивания" индексов

Модульная арифметика - % операция, возвращающая остаток от деления

Пример кольцевой арифметики
text
MAX_SIZE = 5
rear = 4
Новая позиция: rear = (4 + 1) % 5 = 0
Общие термины для всех программ
Структуры управления
Цикл while - выполнение блока кода пока условие истинно

Условный оператор if - выполнение кода при выполнении условия

Оператор switch - выбор из нескольких вариантов

Операции
% (остаток от деления) - a % b возвращает остаток от деления a на b

& (побитовое И) - сравнивает соответствующие биты двух чисел

| (побитовое ИЛИ) - устанавливает бит в 1 если хотя бы один из соответствующих битов равен 1

^ (побитовое XOR) - устанавливает бит в 1 если соответствующие биты разные

<< (побитовый сдвиг влево) - сдвигает биты влево, умножая на 2

>> (побитовый сдвиг вправо) - сдвигает биты вправо, деля на 2

Типы данных
int - целое число (обычно 4 байта)

long long - длинное целое (обычно 8 байт)

unsigned - беззнаковый тип (только положительные числа)

char - символ (1 байт)

Константы из limits.h
INT_MAX - максимальное значение int

INT_MIN - минимальное значение int

CHAR_BIT - количество бит в байте (обычно 8)

Указатели и массивы
*** (указатель)** - переменная, хранящая адрес другой переменной

& (адрес) - оператор взятия адреса

[] (индексация массива) - доступ к элементу массива по индексу

Функции ввода/вывода
printf() - форматированный вывод

scanf() - форматированный ввод

%d - спецификатор формата для целых чисел

%s - спецификатор формата для строк

%c - спецификатор формата для символов

%lld - спецификатор для long long

Рекомендации по тестированию
Для программ 1-3:
Проверьте граничные случаи (0, максимальные значения)

Сравните результаты с ручными расчетами

Протестируйте разные системы счисления (2, 8, 16)

Для стека и очередей:
Проверьте переполнение и опустошение

Убедитесь, что операции выполняются в правильном порядке

Протестируйте последовательности операций

Для кода Хэмминга:
Проверьте на небольших числах для легкости ручной проверки

Убедитесь, что контрольные биты вычисляются правильно

Проверьте восстановление при ошибках (если реализовано)